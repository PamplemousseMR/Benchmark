#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include "mod_arith.h"
#include "splittable_mrg.h"

typedef struct mrg_transition_matrix {
    uint_fast32_t s, t, u, v, w;
    /* Cache for other parts of matrix (see mrg_update_cache function)     */
    uint_fast32_t a, b, c, d;
} mrg_transition_matrix;

/* r may alias st */
static void mrg_apply_transition(const mrg_transition_matrix* __restrict  mat, const mrg_state* __restrict  st, mrg_state* r) {
    uint_fast32_t o1 = mod_mac_y(mod_mul(mat->d, st->z1), mod_mac4(0, mat->s, st->z2, mat->a, st->z3, mat->b, st->z4, mat->c, st->z5));
    uint_fast32_t o2 = mod_mac_y(mod_mac2(0, mat->c, st->z1, mat->w, st->z2), mod_mac3(0, mat->s, st->z3, mat->a, st->z4, mat->b, st->z5));
    uint_fast32_t o3 = mod_mac_y(mod_mac3(0, mat->b, st->z1, mat->v, st->z2, mat->w, st->z3), mod_mac2(0, mat->s, st->z4, mat->a, st->z5));
    uint_fast32_t o4 = mod_mac_y(mod_mac4(0, mat->a, st->z1, mat->u, st->z2, mat->v, st->z3, mat->w, st->z4), mod_mul(mat->s, st->z5));
    uint_fast32_t o5 = mod_mac2(mod_mac3(0, mat->s, st->z1, mat->t, st->z2, mat->u, st->z3), mat->v, st->z4, mat->w, st->z5);
    r->z1 = o1;
    r->z2 = o2;
    r->z3 = o3;
    r->z4 = o4;
    r->z5 = o5;
}

static void mrg_step(const mrg_transition_matrix* mat, mrg_state* state) {
    mrg_apply_transition(mat, state, state);
}

static void mrg_orig_step(mrg_state* state) { /* Use original A, not fully optimized yet */
    uint_fast32_t new_elt = mod_mac_y(mod_mul_x(state->z1), state->z5);
    state->z5 = state->z4;
    state->z4 = state->z3;
    state->z3 = state->z2;
    state->z2 = state->z1;
    state->z1 = new_elt;
}

#ifndef DUMP_TRANSITION_TABLE
#include "mrg_transitions.c"
/* Defines this:
extern const mrg_transition_matrix mrg_skip_matrices[][256]; */
#endif

void mrg_skip(mrg_state* state, uint_least64_t exponent_high, uint_least64_t exponent_middle, uint_least64_t exponent_low) {
    /* fprintf(stderr, "skip(%016" PRIXLEAST64 "%016" PRIXLEAST64 "%016" PRIXLEAST64 ")\n", exponent_high, exponent_middle, exponent_low); */
    int byte_index;
    for (byte_index = 0; exponent_low; ++byte_index, exponent_low >>= 8) {
        uint_least8_t val = (uint_least8_t)(exponent_low & 0xFF);
        if (val != 0) mrg_step(&mrg_skip_matrices[byte_index][val], state);
    }
    for (byte_index = 8; exponent_middle; ++byte_index, exponent_middle >>= 8) {
        uint_least8_t val = (uint_least8_t)(exponent_middle & 0xFF);
        if (val != 0) mrg_step(&mrg_skip_matrices[byte_index][val], state);
    }
    for (byte_index = 16; exponent_high; ++byte_index, exponent_high >>= 8) {
        uint_least8_t val = (uint_least8_t)(exponent_high & 0xFF);
        if (val != 0) mrg_step(&mrg_skip_matrices[byte_index][val], state);
    }
}

#ifdef DUMP_TRANSITION_TABLE
const mrg_transition_matrix mrg_skip_matrices[][256] = {}; /* Dummy version */

void dump_mrg(FILE* out, const mrg_transition_matrix* m) {
    /* This is used as an initializer for the mrg_transition_matrix struct, so
   * the order of the fields here needs to match the struct
   * mrg_transition_matrix definition in splittable_mrg.h */
    fprintf(out, "{%" PRIuFAST32 ", %" PRIuFAST32 ", %" PRIuFAST32 ", %" PRIuFAST32 ", %" PRIuFAST32 ", %" PRIuFAST32 ", %" PRIuFAST32 ", %" PRIuFAST32 ", %" PRIuFAST32 "}\n", m->s, m->t, m->u, m->v, m->w, m->a, m->b, m->c, m->d);
}

void dump_mrg_powers(void) {
    /* transitions contains A^(256^n) for n in 0 .. 192/8 */
    int i, j;
    mrg_transition_matrix transitions[192 / 8];
    FILE* out = fopen("mrg_transitions.c", "w");
    if (!out) {
        fprintf(stderr, "dump_mrg_powers: could not open mrg_transitions.c for output\n");
        exit (1);
    }
    fprintf(out, "/* Copyright (C) 2010 The Trustees of Indiana University.                  */\n");
    fprintf(out, "/*                                                                         */\n");
    fprintf(out, "/* Use, modification and distribution is subject to the Boost Software     */\n");
    fprintf(out, "/* License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at */\n");
    fprintf(out, "/* http://www.boost.org/LICENSE_1_0.txt)                                   */\n");
    fprintf(out, "/*                                                                         */\n");
    fprintf(out, "/*  Authors: Jeremiah Willcock                                             */\n");
    fprintf(out, "/*           Andrew Lumsdaine                                              */\n");
    fprintf(out, "\n");
    fprintf(out, "/* This code was generated by dump_mrg_powers() in splittable_mrg.c;\n * look there for how to rebuild the table. */\n\n");
    fprintf(out, "#include \"splittable_mrg.h\"\n");
    fprintf(out, "const mrg_transition_matrix mrg_skip_matrices[][256] = {\n");
    for (i = 0; i < 192 / 8; ++i) {
        if (i != 0) fprintf(out, ",");
        fprintf(out, "/* Byte %d */ {\n", i);
        mrg_transition_matrix m;
        mrg_make_identity(&m);
        dump_mrg(out, &m);
        if (i == 0) {
            mrg_make_A(&transitions[i]);
        } else {
            mrg_power(&transitions[i - 1], 256, &transitions[i]);
        }
        fprintf(out, ",");
        dump_mrg(out, &transitions[i]);
        for (j = 2; j < 256; ++j) {
            fprintf(out, ",");
            mrg_power(&transitions[i], j, &m);
            dump_mrg(out, &m);
        }
        fprintf(out, "} /* End of byte %d */\n", i);
    }
    fprintf(out, "};\n");
    fclose(out);
}

/* Build this file with -DDUMP_TRANSITION_TABLE on the host system, then build
 * the output mrg_transitions.c */
int main(int argc, char** argv) {
    dump_mrg_powers();
    return 0;
}
#endif

/* Returns integer value in [0, 2^31-1) using original transition matrix. */
uint_fast32_t mrg_get_uint_orig(mrg_state* state) {
    mrg_orig_step(state);
    return state->z1;
}

/* Returns real value in [0, 1) using original transition matrix. */
double mrg_get_double_orig(mrg_state* state) {
    return (double)mrg_get_uint_orig(state) * .000000000465661287524579692 /* (2^31 - 1)^(-1) */ +
            (double)mrg_get_uint_orig(state) * .0000000000000000002168404346990492787 /* (2^31 - 1)^(-2) */
            ;
}

void mrg_seed(mrg_state* st, const uint_fast32_t seed[5]) {
    st->z1 = seed[0];
    st->z2 = seed[1];
    st->z3 = seed[2];
    st->z4 = seed[3];
    st->z5 = seed[4];
}
